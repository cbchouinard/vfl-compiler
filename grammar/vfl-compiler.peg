{
  var p, parser, cs, leftVarNames, superLeftVarNames, rightVarNames, superRightVarNames, standardGapNames, getSuperViewName, getGapString, sizeVarNames; 

  p = parser = this;

  sizeVarNames = ["width", "height"];
  leftVarNames = ["right", "bottom"];
  superLeftVarNames = ["left", "top"];
  rightVarNames = ["left", "top"];
  superRightVarNames = ["right", "bottom"];

  cs = parser.cs = [];

  parser.addC = function (c) {
    cs.push(c);
  };

  parser.addPreds = function (view,preds,d) {
    var pred, ccss, eq, exps, exp;
    if (preds) {      
      for (var i = 0; i < preds.length; i++) {
        pred = preds[i];
        eq = pred[0];
        ccss = view + "[" + sizeVarNames[d] + "] " + eq + " ";
        exps = pred[1];
        for (var j = 0; j < exps.length; j++) {       
          exp = exps[j];
          if (exp[0] === "view") {
            exp = exp[1] + "[" + sizeVarNames[d] + "]";
          }
          ccss += exp + " ";
        }
        ccss += pred[2]; // strength & weight
        cs.push(ccss.trim());
      }
    }
  };

  parser.defaultChainObject = {
    headEq: "==",
    value: "",
    tailEq: "",
    s: ""
  };

  parser.chainTailEqMap = {
    "<=": ">=",
    ">=": "<=",
    "==": "==",
    "<" : ">",
    ">" : "<" 
  };

  parser.addChains = function (views,o) {
    var chains, chain, prop, preds, connector, ccss, view, pred;
    chains = o.chains;
    if (chains) {            
      for (var i = 0; i < chains.length; i++) {
        chain = chains[i];
        prop = chain[0];
        preds = chain[1];
        if (preds === "") {
          preds = [parser.defaultChainObject];
        } // load default chain predicate
        for (var j = 0; j < preds.length; j++) {
          pred = preds[j];
          ccss = "";
          for (var k = 0; k < views.length - 1; k++) {
            view = views[k];  
            if (pred.headEq === "") {
              pred.headEq = parser.defaultChainObject.headEq;
            }
            ccss += " " + view + "[" + prop + "] " + pred.headEq;
            if (pred.value !== "") {
              ccss += " " + pred.value;
              if (views.length > 1) {
                if (pred.tailEq === "") {
                  pred.tailEq = parser.chainTailEqMap[pred.headEq];
                }
                ccss += " " + pred.tailEq;
              }
              else {
                ccss += " " + pred.s;
                cs.push(ccss.trim());
              }
            }
          }
          if (views.length > 1) {
             ccss += " " + views[views.length-1] + "[" + prop + "]" + " " + pred.s;
             cs.push(ccss.trim());
          }
        }
      }
    } 
  };

  getSuperViewName = function (o) {
    if (o.in === undefined) {
      return "::this";
    }
    return o.in;
  };

  parser.getLeftVar = function (view, dimension, o) {
    var varName;
    if (view === "|") {
      view = getSuperViewName(o);
      varName = superLeftVarNames[dimension];
    }
    else {
      varName = leftVarNames[dimension];
    }
    return view + "[" + varName + "]";
  };
  
  parser.getRightVar = function (view, dimension, o) {
    var varName;
    
    if (view === "|") {
      view = getSuperViewName(o);
      varName = superRightVarNames[dimension];
    }
    else {
      varName = rightVarNames[dimension];
      
    }
    return view + "[" + varName + "]";
  };
  
  standardGapNames = ["[hgap]", "[vgap]"];
  
  getGapString = function (g,d) {
    if (g === undefined) {return "";}
    if (g === "__STANDARD__") {g = standardGapNames[d];}
    return "+ " + g;
  };

  parser.getConnectionString = function (c,d) {
    return (getGapString(c.gap,d) + " " + c.op).trim();
  };

  parser.getResults = function () {
    return [
      ["ccss"].concat(this.cs)
    ];
  };

  parser.error = function (m,l,c) {
    if (!!l && !!c) {
      m = m + " {line:" + l + ", col:" + c + "}";
    }
    console.error(m);
    return m;
  };

  parser.join = function (a) {
    if (a.join){return a.join("");}
    return a;
  };
}

start
  = __ Statement* __ { return parser.getResults(); }

debug 
  = __ vfl:Statement* __ { return parser.getResults().concat(vfl); }

Statement
  = exp:VFLStatement EOS __ { return exp; }

VFLStatement
  = d:Dimension __ head:View
    tail:(__ Connection? __ View)* __ o:Options?
    __ s:StrengthAndWeight?         {
      var connection, view2, result, ccss, headView, chainedViews;      
      result = head;      
      headView = head.view;
      chainedViews = [];      
      if (headView !== "|") {chainedViews.push(headView);}
      parser.addPreds(headView,head.preds,d);      
      for (var i = 0; i < tail.length; i++) {        
        connection = tail[i][1];
        view2 = tail[i][3].view;
        if (view2 !== "|") {chainedViews.push(view2);}
        parser.addPreds(view2,tail[i][3].preds,d);
        result = [
          //"c",
          connection,
          result,
          view2
        ];
        ccss = parser.getLeftVar(headView, d, o) + " " + parser.getConnectionString(connection, d) + " " + parser.getRightVar(view2, d, o) + " " + s;
        parser.addC(
          ccss.trim()
        );
        headView = view2;
      }
      parser.addChains(chainedViews,o);
      return {'vfl':d, o:o};
    }

Dimension
  = ("@horizontal" / "@-gss-horizontal" / "@-gss-h") {return 0;}
  / ("@vertical" / "@-gss-vertical" / "@-gss-v") {return 1;}


Options
  = os:Option+  {
    var obj = {};
    obj.chains = [];
    for (var i = 0; i < os.length; i++) {    
      obj[os[i].key] = os[i].value;
      // proccess chains
      if (!!os[i].chain) {obj.chains.push(os[i].chain);}
    }
    return obj;
  }

Option
  = __ chain:Chain { return chain; }
  / __ key:NameChars+ "(" value:NameChars+ ")" {return {key:key.join(''), value:value.join('')};}

Chain 'Chain'
  = "chain-" prop:NameChars+ preds:ChainPredicate? { return {'chain':[prop.join(""),preds]};}

ChainPredicate
  = "(" items:ChainPredicateItems+ ")" {return items;}

ChainPredicateItems
  = item:ChainPredicateItem _? ","? {return item;}

// TODO: make more DRY... if all rules are optional sends parser into infinite loop
ChainPredicateItem
  = headEq:PredEq _  value:ChainPredVal? _? tailEq:PredEq? _? s:StrengthAndWeight? {
      return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};}
  / headEq:PredEq? _? value:ChainPredVal _? tailEq:PredEq? _? s:StrengthAndWeight? {
      return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};}
  / headEq:PredEq? _? value:ChainPredVal? _? tailEq:PredEq? _? s:StrengthAndWeight {
      return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};}

ChainPredVal
  = [^>=<!) ]+

View
  = "[" name:NameChars+ p:Predicate? "]"  {return {view:name.join(""),preds:p};}
  / "|"                                   {return {view:"|"};}
  // errorr 

Predicate
  = "(" preds:(PredEq PredExpression StrengthAndWeight? _? PredSeperator _?)+ ")" {return preds;}

PredExpression 
  = (PredOp / PredLiteral / PredVariable / PredViewVariable / PredView )+

PredEq
  = _? eq:("==" / "<=" / "<" / ">=" / ">" / "=<"{return "<=";} / "=>"{return ">=";}) _?  {return eq;}

PredOp 
  = op:[+\-/*] _? {return op;}

PredView
  = name:NameChars+ _? {return ["view",name.join("")];}

PredLiteral
  = n:Number+ _? {return n.join("");}

PredVariable
  = "[" name:NameChars+ "]" _?  {return "[" + name.join("") + "]";}

PredViewVariable
  = view:NameChars+ "[" prop:NameChars+ "]" _?  {return view.join("") + "[" + prop.join("") + "]";}

PredSeperator
  = ","? {return "";}

Connection
  = "-" gap:GapChars+ "-"  {return {op:"==",gap:gap.join("")};}
  / "-"                    {return {op:"==",gap:"__STANDARD__"};}
  / "~" gap:GapChars+ "~"  {return {op:"<=",gap:gap.join("")};}
  / "~" "-" "~"            {return {op:"<=",gap:"__STANDARD__"};}
  / "~"                    {return {op:"<="};}
  / ""                     {return {op:"=="};}

GapChars 
  = [a-zA-Z0-9#._$]

  
StrengthAndWeight
  = "!" s:([a-zA-Z]+)? w:([0-9]+)? {  return "!" + p.join(s) + p.join(w);}
  / "!" .? {return parser.error("Invalid Strength or Weight",line,column);}


Strength
  = ("require"  / "REQUIRE"  / "Require")  {return "require";}
  / ("strong"   / "STRONG"   / "Strong")   {return "strong";}
  / ("medium"   / "MEDIUM"   / "Medium")   {return "medium";}
  / ("weak"     / "WEAK"     / "Weak")     {return "weak";}
  / ("required" / "REQUIRED" / "Required") {return "require";}

  

NameChars
  = [a-zA-Z0-9#.\-_$]

NameCharsWithSpace
  = NameChars / " "

Literal
  = val:Number {
    return [ "number",
      val
    ];
  }

Number
  = Real / Integer

Integer
  = digits:[0-9]+ {
    return parseInt(digits.join(""), 10);
  }

Real
  = digits:(Integer "." Integer) {
    return parseFloat(digits.join(""));
  }

SignedInteger
  = [-+]? [0-9]+

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

EOS
  = __ ";"
  / _ LineTerminatorSequence
  / __ EOF

EOF
  = !.

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)* (LineTerminator / EOF)
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*
